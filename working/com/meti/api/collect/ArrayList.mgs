import com.meti.api {
	collect {
		Array
	},
	core {
		StandardOps,
		Comparable
	},
	memory {
		Allocator,
		StandardAllocator
	}
}

const ArrayList = class[T]{
	const allocator : Allocator,
	const array : Array[T],
	const size : I16,
	const comparator : (T, T) => I16
} => {
	called const get = (index : U16) => {
		if (index < 0) throw IndexException("Index can't be negative");
        if (index >= size) throw IndexException("Index is equal to or exceeds the size of this list.");
        return array(index);
	}

	const indexOf = (value : T) => {
		for(let i = 0; i < size; i++){
			if(!comparator(array[i], value)){
				return i;
			}
		}
		return -1;
	}

	const contains = (value : T) => indexOf(vlaue) != -1;

	const resizeTo = (index : U16) => {
		let capacity = array.length();
		if(index < capacity) return array;
		if(!capacity) capacity = 1;
		while(capacity < index + 1) size *= 2;

		const copy = allocator(capacity * T.type.size);
		for(let i = 0; i < size; i++) copy(i, array(i));
		return copy;
	}
}

single ArrayLists {
	const DefaultSize = 10;

	const empty = [T]{
		const allocator : Allocator = StandardAllocator,
		const comparator : (T, T) => I16
	} => ArrayList(allocator, allocator(T.size * DefaultSize), 0, comparator);

	const of = [T]{
		const allocator : Allocator = StandardAllocator,
		const comparator : (T, T) => I16,
		const elements : T...
	} => ArrayList(allocator, elements, elements.length, comparator);

	const ofComparables = [T < Comparable[T]]{
		const allocator : Allocator = StandardAllocator,
		const elements : T...
	} => ArrayList(allocator, elements, elements.length, _.compareTo(_));

	const range = {
		const allocator : Allocator = StandardAllocator,
		const start : T,
		const end : T,
		const comparator : (T, T) => I16,
		const incrementer : T => T
	} => {
		let current = start;
		let list = empty(allocator, comparator);
		while(comparator.apply(current, end) != 0){
			list += current;
			current = next.apply(current);
		}
		return list;
	}
}